#!/bin/bash

# Configuration
SERVER_NAME="<Server hostname for example gitea>"  # Set differently for each server
TELEGRAM_BOT_TOKEN="<Your token here>"
TELEGRAM_CHAT_ID="<Your chatID here>"
THRESHOLD=80
CHECK_INTERVAL=15  # 5 seconds

#Firewall Configs
FIREWALL_CHECK_INTERVAL=15
RULES_SNAPSHOT="/var/tmp/iptables_snapshot.txt"

# Get CPU core count
CPU_CORES=$(nproc)

# Log monitoring configuration
case "$SERVER_NAME" in
    "reverse-proxy")
        declare -A LOG_PATTERNS=(
            ["/path/to/your/logs/httpsAccess.log"]="\"status\":(4[0-9]{2}|5[0-9]{2})"
        )
        ;;
    "budget")
        declare -A LOG_PATTERNS=(
            ["/path/to/your/logs/panic.log"]=".*" # Return all new entries
        )
        ;;
    "Gitea")
        # Add Gitea logs here if needed later
        ;;
esac

send_telegram_message() {
    local message="$1"
    local prefix="[$SERVER_NAME]"
    message="$prefix $message"
    curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
        -d "chat_id=${TELEGRAM_CHAT_ID}" \
        -d "text=${message}" \
        -d "parse_mode=HTML"
}

monitor_system() {
    while true; do
        # CPU Load Check (using 1-minute load average)
        load_1min=$(uptime | awk -F'load average: ' '{print $2}' | cut -d, -f1)
        load_1min=${load_1min%.*}  # Convert to integer
        if [ "$load_1min" -gt "$CPU_CORES" ]; then
            send_telegram_message "ðŸš¨ 1 Minute LOAD: ${load_1min} (cores: ${CPU_CORES})"
        fi

        # Memory Check
        memory_usage=$(free | grep Mem | awk '{print ($3/$2) * 100.0}' | cut -d. -f1)
        if [ "$memory_usage" -gt "$THRESHOLD" ]; then
            send_telegram_message "ðŸš¨ HIGH MEMORY: ${memory_usage}%"
        fi

        # Disk Check
        disk_usage=$(df -h / | awk 'NR==2 {print $5}' | cut -d% -f1)
        if [ "$disk_usage" -gt "$THRESHOLD" ]; then
            send_telegram_message "ðŸš¨ HIGH DISK: ${disk_usage}%"
        fi

        # IO Check - using two samples for actual interval measurement
        io_usage=$(iostat -x 1 2 | grep "sda" | tail -n1 | awk '{print $NF}' | cut -d. -f1)
        if [ -n "$io_usage" ] && [ "$io_usage" -eq "$io_usage" ] 2>/dev/null; then
            if [ "$io_usage" -gt "$THRESHOLD" ]; then
                send_telegram_message "ðŸš¨ I/O: ${io_usage}%"
            fi
        fi


        sleep "$CHECK_INTERVAL"
    done
}

monitor_ssh() {
    tail -Fn0 /var/log/auth.log | while read line; do
        if [ -z "$line" ]; then
            logger "Telegram monitor: Empty line received"
            continue
        fi

	# Added Space after Accepted to differentiate it from:
	# PubkeyAcceptedAlgorithms
        if echo "$line" | grep -q "Accepted "; then
            # Immediately save the line and log it
            captured_line="$line"
            logger "Telegram monitor: Processing login: $captured_line"

            # Process the saved line
            user=$(echo "$captured_line" | grep -oP '(?<=for )\w+')
            ip=$(echo "$captured_line" | grep -oP '(?<=from )[0-9\.]+')

            if [ -z "$user" ] || [ -z "$ip" ]; then
                logger "Telegram monitor: WARNING - Malformed login. User='$user' IP='$ip'"
                send_telegram_message "âš ï¸ WARNING: Malformed login detected. Check syslog."
                continue
            fi

            send_telegram_message "ðŸ” SSH Login: $user from $ip on ${SERVER_NAME}"
        fi
    done
}

# Function to get current iptables state (without counters)
get_iptables_state() {
    # Get rules with interfaces but strip the packet/byte counter columns
    iptables -L -n -v --line-numbers | awk '
        # For Chain lines, only keep "Chain CHAINNAME"
        /^Chain/ { 
            print $1, $2
            next
        }
        # Keep header lines and empty lines as-is
        /^num/ || /^$/ { print; next }
        # For rule lines, remove columns 2 and 3 (pkts and bytes)
        { $2=""; $3=""; print }
    '
}

monitor_firewall_rules() {
    # Create initial snapshot if it doesn't exist
    if [ ! -f "$RULES_SNAPSHOT" ]; then
        get_iptables_state > "$RULES_SNAPSHOT"
        logger "Telegram monitor: Initial iptables snapshot created"
    fi
    
    while true; do
        # Get current state
        current_state=$(get_iptables_state)
        
        # Compare with snapshot
        if ! diff -q <(cat "$RULES_SNAPSHOT") <(echo "$current_state") > /dev/null; then
            # Rules changed! Get the diff
            changes=$(diff -u "$RULES_SNAPSHOT" <(echo "$current_state"))
            
            logger "Telegram monitor: IPTables rules changed"
            
            # Send alert with changes
            send_telegram_message "âš ï¸ IPTables rules changed!

<pre>${changes}</pre>"
            
            # Update snapshot
            echo "$current_state" > "$RULES_SNAPSHOT"
        fi
        
        sleep "$FIREWALL_CHECK_INTERVAL"
    done
}

monitor_logs() {
    for log_file in "${!LOG_PATTERNS[@]}"; do
        if [ ! -f "$log_file" ]; then
            logger "Telegram monitor: Log file $log_file not found, skipping"
            continue
        fi
        
        pattern="${LOG_PATTERNS[$log_file]}"
        
        tail -Fn0 "$log_file" | grep --line-buffered -E "$pattern" | while read line; do
            # For panic.log, truncate the stack field
            if [[ "$log_file" == *"panic.log"* ]]; then
                formatted=$(echo "$line" | jq -r 'del(.stack) | .' 2>/dev/null || echo "$line")
                send_telegram_message "ðŸ”´ Log Alert [$log_file]:
<pre>$formatted</pre>
(stack trace truncated - check server logs)"
            else
                formatted=$(echo "$line" | jq -r '.' 2>/dev/null || echo "$line")
                send_telegram_message "ðŸ”´ Log Alert [$log_file]:
<pre>$formatted</pre>"
            fi
        done &
    done
}

# Keep script running and handle termination gracefully
cleanup() {
     send_telegram_message "âš ï¸ Monitoring script stopped at $(date '+%Y-%m-%d %H:%M:%S')"
     kill $(jobs -p) 2>/dev/null
     exit 0
}

# Set up trap for script termination
trap cleanup SIGTERM SIGINT SIGHUP

# Start monitoring
send_telegram_message "ðŸŸ¢ Server monitoring started on ${SERVER_NAME}"

# Run monitors in parallel
monitor_system &
monitor_ssh &
monitor_firewall_rules &
monitor_logs &

wait
